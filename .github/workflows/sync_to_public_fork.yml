name: Sync to Public Fork

on:
  workflow_dispatch: {}
  push:
    branches:
      - master

permissions:
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Strip private-only files
        shell: bash
        run: |
          set -eux

          # 1) Remove Copilot/agent instructions (must not be public)
          rm -f .github/copilot-instructions.md || true

          # 1.5) Remove internal project notes
          rm -f "项目情况.txt" || true

          # 1.8) Do not sync docs-site to the public fork
          rm -rf docs-site || true

          # 2) Remove all GitHub Actions workflows (must not be public)
          rm -rf .github/workflows || true

          # Stage removals for the sync commit
          git add -A

          # Create a sync-only commit on the runner so the public fork receives the stripped tree
          if ! git diff --cached --quiet; then
            git -c user.name='public-sync-bot' -c user.email='public-sync-bot@users.noreply.github.com' \
              commit -m 'chore: sync stripped files to public fork'
          fi

      - name: Setup SSH for GitHub
        shell: bash
        run: |
          set -eux
          mkdir -p ~/.ssh

          # Prefer base64 secret to avoid multiline formatting/truncation issues.
          # - PUBLIC_FORK_SSH_PRIVATE_KEY_B64: base64 of the private key file (recommended)
          # - PUBLIC_FORK_SSH_PRIVATE_KEY    : raw private key content (multiline)
          if [[ -n "${{ secrets.PUBLIC_FORK_SSH_PRIVATE_KEY_B64 }}" ]]; then
            printf '%s' "${{ secrets.PUBLIC_FORK_SSH_PRIVATE_KEY_B64 }}" | tr -d '\r\n ' | base64 -d > ~/.ssh/id_ed25519
          else
            if [[ -z "${{ secrets.PUBLIC_FORK_SSH_PRIVATE_KEY }}" ]]; then
              echo "ERROR: secrets.PUBLIC_FORK_SSH_PRIVATE_KEY (or _B64) is empty/missing." >&2
              echo "Add one of them in GitHub repo Settings -> Secrets and variables -> Actions." >&2
              exit 1
            fi
            printf '%s' "${{ secrets.PUBLIC_FORK_SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/id_ed25519
          fi
          chmod 600 ~/.ssh/id_ed25519
          chmod 700 ~/.ssh

          # Normalize common formatting issues from Secrets:
          # - Sometimes newlines are stored as literal '\n' sequences (single-line secret)
          # - Trailing spaces can break parsing
          if [[ "$(wc -l < ~/.ssh/id_ed25519 | tr -d ' ')" == "1" ]] && grep -q '\\n' ~/.ssh/id_ed25519; then
            perl -0777 -pe 's/\\n/\n/g' ~/.ssh/id_ed25519 > ~/.ssh/id_ed25519.tmp
            mv ~/.ssh/id_ed25519.tmp ~/.ssh/id_ed25519
            chmod 600 ~/.ssh/id_ed25519
          fi
          sed -i 's/[ \t]\+$//' ~/.ssh/id_ed25519

          echo "[debug] key lines=$(wc -l < ~/.ssh/id_ed25519 | tr -d ' ') bytes=$(wc -c < ~/.ssh/id_ed25519 | tr -d ' ')"
          echo "[debug] key header/footer (safe):"
          (grep -m1 '^-----BEGIN ' ~/.ssh/id_ed25519 || true) | sed 's/./*/g'
          (grep -m1 '^-----END ' ~/.ssh/id_ed25519 || true) | sed 's/./*/g'

          # Basic sanity checks to detect truncated/incorrect secrets early.
          if ! grep -q '^-----BEGIN ' ~/.ssh/id_ed25519; then
            echo "ERROR: SSH key does not contain a BEGIN header. This is not a valid OpenSSH private key." >&2
            exit 1
          fi
          if ! grep -q '^-----END ' ~/.ssh/id_ed25519; then
            echo "ERROR: SSH key is missing an END footer. The secret is likely truncated or pasted incorrectly." >&2
            echo "Fix: re-paste the full private key, or (recommended) store base64 in PUBLIC_FORK_SSH_PRIVATE_KEY_B64." >&2
            exit 1
          fi
          if [[ "$(wc -l < ~/.ssh/id_ed25519 | tr -d ' ')" -lt "5" ]]; then
            echo "ERROR: SSH key has too few lines; it looks truncated." >&2
            echo "Fix: use base64 secret (PUBLIC_FORK_SSH_PRIVATE_KEY_B64) to avoid formatting issues." >&2
            exit 1
          fi

          # Validate key format early to provide actionable errors.
          # Common mistake: pasting the .pub (single-line) into the secret.
          if ! ssh-keygen -yf ~/.ssh/id_ed25519 >/dev/null 2>&1; then
            echo "ERROR: SSH private key is invalid or unreadable (ssh-keygen failed)." >&2
            echo "Hint: PUBLIC_FORK_SSH_PRIVATE_KEY must be the *private* key file content" >&2
            echo "      (it usually starts with '-----BEGIN OPENSSH PRIVATE KEY-----')." >&2
            echo "      The .pub key must be added to the *public repo* Deploy Keys (Allow write access)." >&2
            echo "      If your private key has a passphrase, re-generate with: ssh-keygen -t ed25519 -N '' ..." >&2
            exit 1
          fi

          for i in 1 2 3 4 5; do
            ssh-keyscan -t ed25519,ecdsa,rsa github.com >> ~/.ssh/known_hosts 2>/dev/null && break
            sleep 2
          done
          test -s ~/.ssh/known_hosts

      - name: Push to public fork
        shell: bash
        env:
          PUBLIC_FORK_REPO: ${{ secrets.PUBLIC_FORK_REPO }}
          PUBLIC_FORK_BRANCH: ${{ secrets.PUBLIC_FORK_BRANCH }}
        run: |
          set -eux

          if [[ -z "$PUBLIC_FORK_REPO" ]]; then
            echo "ERROR: secrets.PUBLIC_FORK_REPO is empty/missing."
            echo "Example: git@github.com:<owner>/<repo>.git"
            exit 1
          fi

          BRANCH="${PUBLIC_FORK_BRANCH:-master}"

          git remote add public "$PUBLIC_FORK_REPO" || true
          # Force git/ssh to use our key only (avoid other identities on runner)
          export GIT_SSH_COMMAND="ssh -i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes"
          git push -f public "master:${BRANCH}"
